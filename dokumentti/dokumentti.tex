\documentclass[12pt] {article}
\usepackage[utf8] {inputenc}
\usepackage[finnish] {babel}
\usepackage {amsmath}
\usepackage {amssymb}
\usepackage {amsthm}
\usepackage {mathtools}
\usepackage {graphicx}
\usepackage {listings}
\usepackage {xcolor}

\newcommand{\textbi}[1]{\textit{\textbf{#1}}}

\lstset{basicstyle=\ttfamily\footnotesize, keywordstyle=\color{blue}, commentstyle=\color{green}, breaklines=true, numbers=left, frame=single}

\begin {document}

\title {Projektin dokumentti}
\author {Miska Kananen (652102, TiK, 1.vk)}
\date {\today}
\maketitle

\tableofcontents

\section {Yleiskuvaus}

Toteutin ohjelman, jolla voi renderöidä reaaliajassa kolmioista koostuvia maailmaan sijoitettuja kolmiulotteisia malleja. Mallit voivat olla mielivaltaisia, eivätkä ne ole rajoittuneita esimerkiksi pelkästään suorakulmaisiin seiniin. Mallin ympärillä voi liikkua vapaasti ja kameraa voi kääntää mielivaltaiseen suuntaan.

\section {Käyttöohje}

Kun ohjelma käynnistetään, se lataa mallinnettavan maailman \texttt{world}-nimisestä tekstitiedostosta ohjelman juurikansiosta. Jos lataaminen epäonnistuu, tulostuu tieto tästä standarditulosteeseen.

Kameraa voi liikuttaa eteen, taakse ja sivuille \texttt{W, A, S, D}-näppäimillä. \texttt{Q} ja \texttt{Z} liikuttavat kameraa ylös ja alas. Nuolinäppäimet kääntävät kameraa.

\section {Ohjelman rakenne}

Ohjelma on jaettu komponentteihin siten, että maailman tila, renderöinti ja ruudulle piirto ovat omina erillisinä komponentteinaan.

Luokka \textit{\textbf{Vertex}} kuvaa kolmion nurkkapistettä. Kullakin \textit{Vertexillä} on:
\begin{itemize}
	\item sijainti object spacessa (yksittäisen kappaleen omassa koordinaatistossa)
	\item väri
\end{itemize}

Luokka \textit{\textbf{Triangle}} kuvaa kolmesta \textit{Vertexistä} koostuvaa kolmiota. \textit{Triangle} on avaruuden kappaleiden rakennuspalikka ja yksinkertaisin renderöitävissä oleva primitiivi. \textit{Trianglella} on:
\begin{itemize}
	\item kolme \textit{Vertexiä}, eli kolmion nurkkapisteet object spacessa
	\item materiaali (kertoo miten kolmio piirretään: umpinainen, wireframe)
\end{itemize}

Luokka \textit{\textbf{Model}} mallintaa yksittäistä, kolmioista koostuvaa kappaletta. Kolmiot on aseteltu kappaleen omaan object spaceen. \textit{Modelilla} on:
\begin{itemize}
	\item yhden tai useamman \textit{Trianglen} muodostama mesh eli käytännössä lista kolmioista, jotka muodostavat yhdessä kappaleen
	\item metodit, joilla voi asettaa materiaalin ja värin kerralla koko meshille
\end{itemize}

Luokka \textbi{CollisionBox} kuvaa kappaleen muotoa törmäystunnistuksen kannalta. \textit{CollisionBox} on koordinaattiakselien suuntainen suorakulmainen särmiö, jonka läpi liikkuminen ei ole sallittua. \textit{CollisionBoxilla} on kaksi nurkkapistettä, jotka määrittävät särmiön muodon. Pisteet ovat kappaleen object spacessa, eli samassa koordinaattijärjestelmässä kuin kappaleen \textit{Modelin} verteksit.

Luokka \textit{\textbf{WorldObject}} kuvaa maailmassa olevaa objektia, kuten esimerkiksi seinää. \textit{WorldObjectilla} on
\begin{itemize}
	\item \textit{Model}, joka määrittää kappaleen muodon ja ulkonäön
	\item mahdollinen \textit{CollisionBox}, joka kuvaa kappaleen muotoa törmäystunnistuksen kannalta
	\item metodi, jolla voi kysyä, onko jokin piste kappaleen sisällä
	\item Transform, eli 4x4-matriisi (world matrix), joka kuvaa kappaleen \textit{Modelin} ja \textit{CollisionBoxin} verteksit object spacesta world spaceen. Matriisin avulla asetetaan kappale avaruuteen haluttuun paikkaan ja asentoon.
\end{itemize}

Luokka \textit{\textbf{World}} kuvaa mallinnettavaa avaruutta ja pitää sisällään kaikki avaruudessa olevat kappaleet. \textit{Worldilla} on
\begin{itemize}
	\item lista \textit{WorldObjecteista} sopivine Transformeineen, eli maailmassa olevat kappaleet oikeilla paikoillaan
	\item \textit{Camera}, eli kamera, jonka näkökulmasta maailma renderöidään
	\item metodi, jolla voi kysyä, onko jokin piste maailman kappaleen sisällä
\end{itemize}

Luokka \textit{\textbf{Camera}} määrittää, mistä paikasta maailmaa tarkastellaan ja mihin suuntaan katsotaan. Kamera on aina renderöitäessä oman koordinaatistonsa (view spacen) origossa osoittaen $+z$-suuntaan, muuta maailmaa liikutetaan ja käännetään tarpeen mukaan. \textit{Cameralla} on:
\begin{itemize}
	\item Transform, eli 4x4-matriisi (view matrix), joka kuvaa maailman \textit{Modelien} verteksit world spacesta view spaceen siten, että kamera on origossa $+z$-suunnassa
	\item metodi view matrixin rakentamiseen siten, että kamera on maailmaan nähden halutussa paikassa ja osoittaa haluttuun suuntaan
\end{itemize}

Luokka \textit{\textbf{Renderer}} ottaa renderöitäväksi \textbf{Worldin} ja kuvaa sen \textbf{Modeleiden} verteksit \textit{Cameran} view spacesta clip spaceen, eli koordinaatistoon, jossa tarkastellaan verteksien näkyvyyttä. Tämän jälkeen \textit{Renderer} selvittää, mitkä \textit{Triangleista} ovat kameran näkökentässä, hylkää sen ulkopuolella olevat, leikkaa sopivasti osittain näkyvissä olevia ja lopulta projisoi koko näkymän clip spacesta image spaceen, eli kaksiulotteiselle tasolle. \textit{Renderer} luo $z$-koordinaatin mukaan järjestetyn listan piirrettävistä \textit{Triangleista}, jotka on projisoitu perspektiiviprojektiolla $xy$-tasolle siten, että niiden $x$- ja $y$-koordinaatit on normalisoitu välille $[-1.0, 1.0]$.

Luokka \textit{\textbf{Screen}} kuvaa näkyvää 2D-pikseliruudukkoa, johon kuva piirretään. \textit{Screen} ottaa \textit{Rendereriltä} listan projisoiduista \textit{Triangleista}, kuvaa niiden verteksit väliltä $[-1.0, 1.0]$ pikselikoordinaatteihin ja piirtää ne näkyviin ruudulle materiaalit ja värit huomioiden.

Luokat \textit{\textbf{Vector4 ja Matrix4}} kuvaavat laskennassa käytettäviä neliulotteisia vektoreita ja matriiseja ja toteuttavat niille tarvittavat laskutoimitukset.

Luokka \textit{\textbf{WorldLoader}} lukee maailman tiedostosta ja luo sen pohjalta \textit{Worldin} ilmentymän.

Luokka \textit{\textbf{Engine}} käynnistää ohjelman, luo käyttöliittymän, kuuntelee käyttäjän syötettä ja päivittää grafiikkaa ja logiikkaa tasaisin väliajoin.

Luokka \textbf{Constants} sisältää ohjelmassa käytettäviä vakioita.

Luokka \textbf{Helpers} sisältää usein tarvittavia apufunktioita.

\section {Algoritmit}

\subsection {Renderöinti}

Ohjelma renderöi kolmioista koostuvia kappaleita rasteroimalla. Kolmioiden verteksit projisoidaan perspektiiviprojektiolla 2D-tasolle näytölle piirtämistä varten. Kolmiot piirretään järjestyksessä kauimmaisesta lähimpään, jolloin kappaleet peittävät niiden takana mahdollisesti olevat toiset kappaleet.

Toinen vaihtoehto olisi voinut olla raycasting, jossa jokaista pikselien saraketta tai pikseliä kohtaan lähetetään kamerasta maailmaan säde, tarkastellaan, mihin kappaleeseen säde osuu ja värjätään pikseli tai sarake sen mukaan. Rasterointi on kuitenkin tehokkaampaa kuin raycasting ja se sallii kameran vapaan liikkeen ja mielivaltaisen maailman geometrian raycastingia helpommin.

\subsubsection {Perspektiiviprojektio}

Kamera on view spacen origossa osoittaen suuntaan $+z$ ja halutaan muodostaa projektio view spacesta tasolle $z = 1$. 

Tarkastellaan projisoitavaa verteksiä $p$, jota kuvaa vektori $p = (x, y, z)$. Yksinkertainen ratkaisu on jakaa $p$ sen $z$-koordinaatilla, jolloin saadaan projektio $p' = (x/z, y/z, 1)$. Ongelmana on, että tämä projektio kadottaa kaiken informaation projisoitavien pisteiden $z$-koordinaateista, jolloin ei voida tietää, missä järjestyksessä kolmiot tulisi piirtää. Tarvitaan projektio, joka kuvaa $x$- ja $y$-koordinaatit vastaavasti kuin aiemmin, mutta säilyttää $z$-koordinaattien keskinäisen järjestyksen.

Kameran näkemä avaruuden alue, eli \textit{view frustum} on kamerasta $+z$-suuntaan kasvava katkaistu pyramidi, joka rajoittuu päistään kahteen tasoon: \textit{near planeen} ja \textit{far planeen}, eli $z =\ $near ja $z =\ $far. View frustumin sisällä olevat verteksit ovat näkyvissä ja muut eivät. Halutaan projektio, joka kuvaa near planella olevan verteksin koordinaattiin $z = 0$, far planella olevan koordinaattiin $z = 1$ ja tasojen välissä olevat koordinaatit järjestyksessä välille $[0, 1]$.

Kun $p$ on homogeenisissä koordinaateissa, eli $p = (x, y, z, (w = 1))$, tällainen projektio saadaan aikaan 4x4-projektiomatriisilla:

\[
	p' = \begin{pmatrix}
	1 & 0 & 0 & 0 \\
	0 & 1 & 0 & 0 \\
	0 & 0 & \frac{far+near}{far-near} & -\frac{2 \cdot far \cdot near}{far-near} \\
	0 & 0 & 1 & 0
	\end{pmatrix} \cdot p
\]

Projektiomatriisi kuvaa verteksin clip spaceen. Kuvauksen jälkeen koordinaatit homogenisoidaan, eli jaetaan sellaisella skalaarilla, että taas pätee $w = 1$. Ne verteksit, jotka olivat alun perin view frustumin sisällä, ovat projektion ja homogenisoinnin jälkeen $x, y \in [-1, 1], z \in [0, 1]$-suorakulmion sisällä ja muut sen ulkopuolella.

Near plane tarvitaan, koska jos near $= 0$, $z$-informaatio menetetään kuvauksessa kuten aiemmin.

\subsubsection {Kolmioiden leikkaus}

Clip spacessa tarkastellaan, mitkä projisoiduista kolmioista ovat kameran näkökentässä. Helppoja tapauksia ovat, jos kolmion kaikki verteksit ovat $x, y \in [-1, 1], z \in [0, 1]$-suorakulmion sisällä tai sen ulkopuolella: sisällä olevat kolmiot ovat kokonaan näkökentässä ja ne piirretään sellaisenaan, ulkona olevat eivät näy ja ne voidaan jättää piirtämättä suoraan.

Mielenkiintoinen tapaus on, jos osa kolmion vertekseistä on kuution sisällä ja osa kuution ulkopuolella. Kolmiota ei voi piirtää kokonaan, koska kaikki verteksit eivät ole näkyvissä, mutta ulkopuolella olevia verteksejä ei voi jättää huomiottakaan, koska verteksit määrittelevät kolmion sivut.

Kolmio leikataan tällöin osiin siten, että saadut osakolmiot ovat joko kokonaan näkyvissä tai näkymättömissä. Leikkaus toistetaan view volumen kullekin sivulle. Voidaan laskea pisteet, jossa kolmion sivut leikkaavat tason, ja näistä pisteistä saadaan kolmiolle uudet kärkipisteet. Tasoja kuvataan yhden tason pisteen ja tason normaalivektorin avulla, ja kolmion sivuja vastaavasti vektorimuodossa kärkipisteen ja sivun suuntavektorin avulla.

\subsubsection {Projisoitujen kolmioiden piirto}

Kuva saadaan näkyviin piirtämällä projisoidut kolmiot 2d-tasolle. Kun \textit{Rendereriltä} on saatu lista projisoiduista kolmioista, jotka ovat image spacessa, verteksien koordinaatit muutetaan pikselikoordinaateiksi ja kolmiot piirretään $z$-järjestyksessä kaukaisimmasta lähimpään tasolle materiaali ja verteksien värit huomioiden.

\subsection {Törmäyksentunnistus}

Maailman kappaleilla on koordinaattiakselien suuntaiset suorakulmion muotoiset collision boxit, jotka ovat juuri niin isoja, että kaikki kappaleen verteksit mahtuvat sen sisälle.

Kun kameraa yritetään liikuttaa, lasketaan piste, johon kamera liikkeen jälkeen päätyisi. Jos piste on jonkin kappaleen collision boxin sisällä, kameran ei anneta liikkua kyseiseen suuntaan.

\section {Tietorakenteet}

Ohjelma käyttää standardikirjaston tarjoamia tietorakenteita, kuten taulukoita, Buffereita ja Mappeja.

Jos renderöintiä tai törmäyksentunnistusta haluttaisiin tehostaa, maailman objektit voitaisiin tallentaa esimerkiksi octreehen, jolloin läpikäytävien objektien määrää saataisiin vähennettyä keskimääräisessä tapauksessa.

\section {Tiedostot}

Renderöitävä maailma ladataan \texttt{world}-nimisestä tekstitiedostosta, jonka rakenne on seuraava.

Ensimmäisellä rivillä on 3 desimaalilukua: kameran $x$, $y$ ja $z$-koordinaatti alussa.

Toisella rivillä on ei-negatiivinen kokonaisluku $n$: kappaleiden määrä.

Seuraa $n$ kappaleen kuvausta. Kunkin kuvauksen rakenne on seuraava:

Kuvauksen ensimmäisellä rivillä on kolme desimaalilukua $x$, $y$ ja $z$: kappaleen keskipisteen (model spacen origon) sijainti world spacessa.

Kuvauksen toisella rivillä on ensin kappaleen tyyppi, joka on joko \texttt{SOLID} tai \texttt{WIREFRAME}. Tyypin jälkeen samalla rivillä on neljä kokonaislukua $r$, $g$, $b$, $a$ $(0 \leq r, g, b, a \leq 255)$, jotka kuvaavat kappaleen värin ja läpinäkyvyyden.

Kuvauksen kolmannella rivillä on epänegatiivinen kokonaisluku $m$: kappaleen kolmioiden määrä.

Seuraa $m$ riviä, joista kullakin on 9 desimaalilukua $x1$, $y1$, $z1$, $x2$, $y2$, $z2$, $x3$, $y3$ ja $z3$: kolmion verteksien koordinaatit.

Esimerkki kelvollisesta tiedostosta, jossa on yksi yhdestä kolmiosta koostuva kappale:

\lstinputlisting {example_world}

\section {Testaus}

Vektorien ja matriisien matemaattisilla operaatioilla on yksikkötestit.

Renderöintiä ja piirtoa ei yksikkötestattu, koska ongelma on hyvin visuaalinen, ja ohjelmaa käyttämällä huomasi helpommin ja monipuolisemmin ongelmia ja puutteita kuin "tämän pikselin pitäisi olla punainen"\ tyyppisillä yksikkötesteillä.

WorldLoaderilla olisi voinut ja kannattaisikin olla yksikkötestit, mutta niiden lisäämiseen ei ollut aikaa.

\section {Puutteet ja viat}

Kolmioita piirrettäessä z-järjestys ei ole täydellinen, eli joissakin tapauksissa toisen kolmion takana oleva kolmio voi näkyä sen edessä. Tällä hetkellä järjestys on, että kolmiot, joiden kameraa lähin verteksi on kauimpana, piirretään ensin. Ongelmia tulee ainakin, jos jokin kolmio on osittain toisen edessä ja osittain toisen takana.

Ongelman voisi ratkaista esimerkisi z-puskurilla, jossa jokaiselle pikselille pidetään yllä pienintä z-arvoa, johon kyseiseen pikseliin on tähän mennessä piirretty. Arvon perusteella voidaan määrittää, pitääkö kyseinen pikseli ylikirjoittaa uutta kolmiota piirrettäessä. Tällöin 2d-piirto pitäisi kuitenkin toteuttaa käsin pikseli pikseliltä ScalaFX:n primitiivien sijaan.

WorldLoaderia ei ole testattu kunnolla: kelvollisen, ei-rajatapaustiedoston pitäisi latautua oikein, mutta on mahdollista, että lataus ei toimi oikein joissakin rajatapauksissa.

\section {Parhaat ja heikoimmat kohdat}

\begin{itemize}
	\item[+] Ohjelma toteuttaa renderöinnin yleisemmin kuin tehtävänannossa vaadittiin: kappaleiden muodot voivat olla mielivaltaisia ja ne voivat olla missä asennossa tahansa. Kameran liike on myös vapaata.
	\item[--] Kolmioiden väri määräytyy verteksien värien keskiarvona. Liukuvärjäys on mahdollinen, ja toteutinkin version, jossa kiinteiden kappaleiden pikselien värit määräytyvät gradienttina riippuen etäisyydestä nurkkapisteisiin, mutta piirto ScalaFX:n Canvasille osoittautui tällöin pullonkaulaksi.
\end{itemize}


\section {Poikkeamat suunnitelmasta}

Ohjelma toteutettiin lähes juurikin suunnitelman mukaan, törmäyksentunnistusta yksinkertaistettiin hieman, koska tarkempi järjestelmä ei ollut kovin relevantti projektin kannalta.

Toteutusjärjestyksessä oli myös pieniä muutoksia. Oikea järjestys oli

\begin{enumerate}
	\item (01.03) Vektorit ja matriisit
	\item (02.03) Vertex, Triangle, Model, WorldObject
	\item (03.03) Camera, World
	\item (15.03) Renderer
	\item (21.03) Screen, ruudulle näkyviin asioita
	\item (30.03) Main loop
	\item (13.04) Kolmioiden leikkaus
	\item (14.04) Törmäyksentunnistus
\end{enumerate}

eli ohjelman sai käyntiin suunniteltua myöhemmin.

\section {Kokonaisarvio}

\section {Viitteet}

\end {document}
